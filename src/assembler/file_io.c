/**
 * @file ./out/scanner/file_io.c
 *
 * This is generated by parser_template_generator. If you edit this file,
 * don't run the generator in this directory. Run it in a different one and
 * then merge the results using a tool like diff.
 *
 * @date Sat Jul 19 18:26:30 2025
 * @author Chuck Tilbury
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>

#include "pointer_list.h"
#include "file_io.h"
#include "scanner.h"
#include "common.h"

static file_t* file_stack = NULL;

/**
 * @brief Open a file for input and push it on the file stack.
 *
 * @param name
 */
void open_file(const char* name, const char* ext) {

    ENTER;
    file_t* ptr = _ALLOC_TYPE(file_t);
    LOCAL_VERBOSITY(1);
    TRACE("trace verbosity: %d", peek_trace_verbosity());
    TRACE("local verbosity: %d", local_verbosity);

    const char* fn = find_file(name, ext);
    yyin = fopen(fn, "r");
    if(yyin == NULL)
        FATAL("cannot open input file: %s: %s", fn, strerror(errno));

    ptr->name = create_string(fn);
    ptr->line = 1;
    ptr->column = 1;
    ptr->is_open = true;
    ptr->fp = yyin;
    ptr->buffer = yy_create_buffer(yyin, YY_BUF_SIZE);
    yy_switch_to_buffer(ptr->buffer);
    ptr->next = NULL;

    // if(file_stack != NULL)
    //     ptr->next = file_stack;
    // file_stack = ptr;
    push_file_buffer(ptr);

    TRACE("open file: %s", fn);
    RETURN();
}

/**
 * @brief Pop the current file off of the stack and destroy it.
 *
 *
int close_file(void) {

    ENTER;
    file_t* ptr = file_stack;
    if(ptr != NULL) {
        TRACE("%s\n", raw_string(ptr->name));
        if(ptr->next != NULL) {
            fclose(ptr->fp);
            destroy_string(ptr->name);
            yy_delete_buffer(ptr->buffer);
            //file_stack = ptr->next;
            pop_file_buffer();
            _FREE(ptr);
        }
        else
            ptr->is_open = false;

        if(file_stack->is_open)
            yy_switch_to_buffer(file_stack->buffer);
    }
    else {
        TRACE("no open file\n");
    }

    RETURN();
}
*/

int get_line_no(void) {

    if(file_stack != NULL)
        return file_stack->line;
    else
        return -1;
}

int get_col_no(void) {

    if(file_stack != NULL)
        return file_stack->column;
    else
        return -1;
}

const char* get_file_name(void) {

    if(file_stack != NULL)
        return get_base_file_name(file_stack->name);
    else
        return NULL;
}

// the others are given by scanner.h
extern int yycolno;
extern int prev_lineno;

void update_numbers(void) {

    int count = 0;
    for(char* tpt = yytext; *tpt != '\0'; tpt++)
        if(*tpt == '\n')
            count++;

    if(count != 0) {
        file_stack->line += count;
        file_stack->column = 1;
    }
    else
        file_stack->column += yyleng;
}

file_t* get_file_buffer(void) {

    if(file_stack)
        return file_stack;
    else
        return NULL;
}

void push_file_buffer(file_t* ptr) {

    if(file_stack != NULL)
        ptr->next = file_stack;
    file_stack = ptr;
}

file_t* pop_file_buffer(void) {

    if(file_stack != NULL)
        file_stack = file_stack->next;

    return file_stack;
}

const char* get_base_file_name(string_t* str) {

    char* tpt = strrchr(str->buffer, '/');
    if(tpt != NULL && tpt[1] != '\0')
        return &tpt[1];
    else
        return str->buffer;
}

